<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="工作原理结构总览Spring Security所解决的问题就是安全访问控制，而安全访问控制功能其实就是对所有进入系统的请求进行拦截，校验每个请求是否能够访问它所期望的资源。根据前边知识的学习，可以通过Filter或AOP等技术来实现，Spring Security对Web资源的保护是靠Filter实现的，所以从这个Filter来入手，逐步深入Spring Security原理。 当初始化Sprin">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringSecurity">
<meta property="og:url" content="http://example.com/2021/03/04/framework/SpringSecurity/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="工作原理结构总览Spring Security所解决的问题就是安全访问控制，而安全访问控制功能其实就是对所有进入系统的请求进行拦截，校验每个请求是否能够访问它所期望的资源。根据前边知识的学习，可以通过Filter或AOP等技术来实现，Spring Security对Web资源的保护是靠Filter实现的，所以从这个Filter来入手，逐步深入Spring Security原理。 当初始化Sprin">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327110951864.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327111323595.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327112016077.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327112657914.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327134101778.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327134546105.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327151131193.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327164316978.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327164546595.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327164630515.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327175423314.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327180748655.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210328133614203.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210328135248167.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210328135634399.png">
<meta property="og:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210328135915042.png">
<meta property="article:published_time" content="2021-03-04T07:48:18.000Z">
<meta property="article:modified_time" content="2021-03-30T12:01:30.319Z">
<meta property="article:author" content="LZ">
<meta property="article:tag" content="Spring技术栈">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/03/04/framework/SpringSecurity/image-20210327110951864.png">

<link rel="canonical" href="http://example.com/2021/03/04/framework/SpringSecurity/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>SpringSecurity | Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/04/framework/SpringSecurity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SpringSecurity
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-04 15:48:18" itemprop="dateCreated datePublished" datetime="2021-03-04T15:48:18+08:00">2021-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-30 20:01:30" itemprop="dateModified" datetime="2021-03-30T20:01:30+08:00">2021-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h2 id="结构总览"><a href="#结构总览" class="headerlink" title="结构总览"></a>结构总览</h2><p>Spring Security所解决的问题就是<strong>安全访问控制</strong>，而安全访问控制功能其实就是对所有进入系统的请求进行拦截，校验每个请求是否能够访问它所期望的资源。根据前边知识的学习，可以通过Filter或AOP等技术来实现，Spring Security对Web资源的保护是靠Filter实现的，所以从这个Filter来入手，逐步深入Spring Security原理。 当初始化Spring Security时，会创建一个名为 SpringSecurityFilterChain 的Servlet过滤器，类型为 org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，因此外部的请求会经过此 类，下图是Spring Security过虑器链结构图： </p>
<p><img src="/2021/03/04/framework/SpringSecurity/image-20210327110951864.png" alt="image-20210327110951864"></p>
<p><img src="/2021/03/04/framework/SpringSecurity/image-20210327111323595.png" alt="image-20210327111323595"></p>
<p>下面介绍过滤器链中主要的几个过滤器及其作用： </p>
<p><strong>SecurityContextPersistenceFilter</strong> 这个Filter是整个拦截过程的入口和出口（也就是第一个和最后一个拦截 器），会在请求开始时从配置好的SecurityContextRepository 中获取 SecurityContext，然后把它设置给 </p>
<p>SecurityContextHolder。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好 的 SecurityContextRepository，同时清除 securityContextHolder 所持有的 SecurityContext； </p>
<p><strong>UsernamePasswordAuthenticationFilter</strong> 用于处理来自表单提交的认证。该表单必须提供对应的用户名和密 码，其内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，这些都可以根据需求做相关改变； </p>
<p><strong>FilterSecurityInterceptor</strong> 是用于保护web资源的，使AccessDecisionManager对当前用户进行授权访问，前 面已经详细介绍过了； </p>
<p><strong>ExceptionTranslationFilter</strong> 能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常： </p>
<p>AuthenticationException 和 AccessDeniedException，其它的异常它会继续抛出。 </p>
<h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><h3 id="认证流程-1"><a href="#认证流程-1" class="headerlink" title="认证流程"></a>认证流程</h3><p><img src="/2021/03/04/framework/SpringSecurity/image-20210327112016077.png" alt="image-20210327112016077"></p>
<p>仔细分析认证过程： </p>
<ol>
<li><p>用户提交用户名、密码被SecurityFilterChain中的UsernamePasswordAuthenticationFilter 过滤器获取到，封装为请求Authentication，通常情况下是UsernamePasswordAuthenticationToken这个实现类。</p>
</li>
<li><p>然后过滤器将Authentication提交至认证管理（AuthenticationManager）进行认证 </p>
</li>
<li><p>认证成功后， AuthenticationManager 身份管理器返回一个被填充满了信息的（包括上面提到的权限信息， 身份信息，细节信息，但密码通常会被移除） Authentication 实例。 </p>
</li>
<li><p>SecurityContextHolder 安全上下文容器将第3步填充了信息的 Authentication ，通过 SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。 可以看出AuthenticationManager接口（认证管理器）是认证相关的核心接口，也是发起认证的出发点，它 的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护着一个 List<AuthenticationProvider> 列表，存放多种认证方式，最终实际的认证工作是由 AuthenticationProvider完成的。咱们知道web表单的对应的AuthenticationProvider实现类为 DaoAuthenticationProvider，它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终 AuthenticationProvider将UserDetails填充至Authentication。 </AuthenticationProvider></p>
</li>
</ol>
<p>认证核心组件的大体关系如下：</p>
<p><img src="/2021/03/04/framework/SpringSecurity/image-20210327112657914.png" alt="image-20210327112657914"></p>
<h3 id="AuthenticationProvider"><a href="#AuthenticationProvider" class="headerlink" title="AuthenticationProvider"></a>AuthenticationProvider</h3><ul>
<li>通过前面的<strong>Spring Security**</strong>认证流程**我们得知，认证管理器（AuthenticationManager）委托 AuthenticationProvider完成认证工作。 AuthenticationProvider是一个接口，定义如下： </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line">    <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication var1)</span> <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>authenticate</strong>()方法定义了<strong>认证的实现过程</strong>，它的参数是一个Authentication，里面包含了登录用户所提交的用 户、密码等。而返回值也是一个Authentication，这个Authentication则是在认证成功后，将用户的权限及其他信 息重新组装后生成。 Spring Security中维护着一个 List<AuthenticationProvider> 列表，存放多种认证方式，不同的认证方式使用不 同的AuthenticationProvider。如使用用户名密码登录时，使用AuthenticationProvider1，短信登录时使用 AuthenticationProvider2等等这样的例子很多。 </AuthenticationProvider></p>
<p>每个AuthenticationProvider需要实现<strong>supports**</strong>（）**方法来表明自己支持的认证方式，如我们使用表单方式认证， 在提交请求时Spring Security会生成UsernamePasswordAuthenticationToken，它是一个Authentication，里面 封装着用户提交的用户名、密码信息。而对应的，哪个AuthenticationProvider来处理它？ **</p>
<p>我们<strong>在DaoAuthenticationProvider</strong>的基类AbstractUserDetailsAuthenticationProvider发现以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Authentication</strong>(认证信息)的结构，它是一个接口，我们之前提到的 UsernamePasswordAuthenticationToken就是它的实现之一 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> var1)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）Authentication是spring security包中的接口，直接继承自Principal类，而Principal是位于 java.security 包中的。它是表示着一个抽象主体身份，任何主体都有一个名称，因此包含一个getName()方法。 </p>
<p>（2）getAuthorities()，权限信息列表，默认是GrantedAuthority接口的一些实现类，通常是代表权限信息的一系 列字符串。 </p>
<p>（3）getCredentials()，凭证信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。 </p>
<p>（4）getDetails()，细节信息，web应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的ip地 </p>
<p>址和sessionId的值。 </p>
<p>（5）**getPrincipal()**，身份信息，大部分情况下返回的是UserDetails接口的实现类，UserDetails代表用户的详细 </p>
<p>信息，那从Authentication中取出来的UserDetails就是当前登录用户信息，它也是框架中的常用接口之一。 </p>
<h3 id="UserDetailService"><a href="#UserDetailService" class="headerlink" title="UserDetailService"></a>UserDetailService</h3><p>1）认识UserDetailsService </p>
<p>现在咱们现在知道DaoAuthenticationProvider处理了web表单的认证逻辑，认证成功后既得到一个Authentication(UsernamePasswordAuthenticationToken实现)，里面包含了身份信息（Principal）。这个身份 信息就是一个 Object ，大多数情况下它可以被强转为UserDetails对象。 </p>
<p>DaoAuthenticationProvider中包含了一个UserDetailsService实例，它负责根据用户名提取用户信息 UserDetails(包含密码)，而后DaoAuthenticationProvider会去对比UserDetailsService提取的用户密码与用户提交 的密码是否匹配作为认证成功的关键依据，因此可以通过将自定义的 UserDetailsService 公开为spring bean来定 义自定义身份验证。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">   <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多人把DaoAuthenticationProvider和UserDetailsService的职责搞混淆，其实UserDetailsService只负责从特定 的地方（通常是数据库）加载用户信息，仅此而已。而DaoAuthenticationProvider的职责更大，它完成完整的认 证流程，同时会把UserDetails填充至Authentication。 </p>
<ol start="2">
<li>认识UserDetails</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它和Authentication接口很类似，比如它们都拥有username，authorities。Authentication的getCredentials()与 UserDetails中的getPassword()需要被区分对待，前者是用户提交的密码凭证，后者是用户实际存储的密码，认证 其实就是对这两者的比对。Authentication中的getAuthorities()实际是由UserDetails的getAuthorities()传递而形 成的。还记得Authentication接口中的getDetails()方法吗？其中的UserDetails用户详细信息便是经过了 AuthenticationProvider认证之后被填充的。 </p>
<p>通过实现UserDetailsService和UserDetails，我们可以完成对用户信息获取方式以及用户信息字段的扩展。 Spring Security提供的InMemoryUserDetailsManager(内存认证)，JdbcUserDetailsManager(jdbc认证)就是 UserDetailsService的实现类，主要区别无非就是从内存还是从数据库加载用户。 </p>
<h3 id="PasswordEncoder"><a href="#PasswordEncoder" class="headerlink" title="PasswordEncoder"></a>PasswordEncoder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   String pw1 = BCrypt.hashpw(<span class="string">&quot;123&quot;</span>, BCrypt.gensalt());</span><br><span class="line">   String pw2 = BCrypt.hashpw(<span class="string">&quot;123&quot;</span>, BCrypt.gensalt());</span><br><span class="line"></span><br><span class="line">   System.out.println(pw1);</span><br><span class="line">   System.out.println(pw2);</span><br><span class="line"></span><br><span class="line">   System.out.println(BCrypt.checkpw(<span class="string">&quot;123&quot;</span>, pw1));</span><br><span class="line">   System.out.println(BCrypt.checkpw(<span class="string">&quot;123&quot;</span>, pw2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际项目中推荐使用BCryptPasswordEncoder, Pbkdf2PasswordEncoder, SCryptPasswordEncoder等</p>
<p>使用BCryptPasswordEncoder </p>
<p>1、配置BCryptPasswordEncoder </p>
<p>在安全配置类中定义： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h2><h3 id="授权流程-1"><a href="#授权流程-1" class="headerlink" title="授权流程"></a>授权流程</h3><p>Spring Security可以通过 http.authorizeRequests() 对web请求进行授权保护。Spring Security使用标准Filter建立了对web请求的拦截，最终实现对资源的授权访问。 Spring Security的授权流程如下：</p>
<p><img src="/2021/03/04/framework/SpringSecurity/image-20210327134101778.png" alt="image-20210327134101778"></p>
<p>分析授权流程：</p>
<p><strong>拦截请求</strong>，已认证用户访问受保护的web资源将被SecurityFilterChain中的 FilterSecurityInterceptor 的子 </p>
<p>类拦截。 </p>
<p><strong>获取资源访问策略</strong>，FilterSecurityInterceptor会从 SecurityMetadataSource 的子类 </p>
<p>DefaultFilterInvocationSecurityMetadataSource 获取要访问当前资源所需要的权限 Collection<ConfigAttribute> 。 </ConfigAttribute></p>
<p>SecurityMetadataSource其实就是读取访问策略的抽象，而读取的内容，其实就是我们配置的访问规则， 读 </p>
<p>取访问策略如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/r/r1&quot;</span>).hasAuthority(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line">        .antMatchers(<span class="string">&quot;/r/r2&quot;</span>).hasAuthority(<span class="string">&quot;p2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>最后，FilterSecurityInterceptor会调用 AccessDecisionManager 进行授权决策，若决策通过，则允许访问资 </p>
<p>源，否则将禁止访问。 </p>
<p>AccessDecisionManager（访问决策管理器）的核心接口如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication var1, Object var2, Collection&lt;ConfigAttribute&gt; var3)</span> <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里着重说明一下decide的参数： </p>
<p>authentication：要访问资源的访问者的身份 </p>
<p>object：要访问的受保护资源，web请求对应FilterInvocation </p>
<p>confifigAttributes：是受保护资源的访问策略，通过SecurityMetadataSource获取。 </p>
<p><strong>decide**</strong>接口就是用来鉴定当前用户是否有访问对应受保护资源的权限。** </p>
<h3 id="授权策略"><a href="#授权策略" class="headerlink" title="授权策略"></a>授权策略</h3><p>AccessDecisionManager采用<strong>投票</strong>的方式来确定是否能够访问受保护资源。 </p>
<p><img src="/2021/03/04/framework/SpringSecurity/image-20210327134546105.png" alt="image-20210327134546105"></p>
<p>通过上图可以看出，AccessDecisionManager中包含的一系列AccessDecisionVoter将会被用来对Authentication 是否有权访问受保护对象进行投票，AccessDecisionManager根据投票结果，做出最终决策。 AccessDecisionVoter是一个接口，其中定义有三个方法，具体结构如下所示。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionVoter</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ACCESS_GRANTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ACCESS_ABSTAIN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ACCESS_DENIED = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">vote</span><span class="params">(Authentication var1, S var2, Collection&lt;ConfigAttribute&gt; var3)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vote()方法的返回结果会是AccessDecisionVoter中定义的三个常量之一。</p>
<p>ACCESS_GRANTED表示同意， ACCESS_DENIED表示拒绝，ACCESS_ABSTAIN表示弃权。</p>
<p>如果一个AccessDecisionVoter不能判定当前 Authentication是否拥有访问对应受保护对象的权限，则其vote()方法的返回值应当为弃权ACCESS_ABSTAIN。 </p>
<p>Spring Security内置了三个基于投票的AccessDecisionManager实现类如下，它们分别是 </p>
<p><strong>AffiffiffirmativeBased</strong>、<strong>ConsensusBased</strong>和<strong>UnanimousBased</strong>，。</p>
<p><strong>AffiffiffirmativeBased</strong>的逻辑是： </p>
<p>（1）只要有AccessDecisionVoter的投票为ACCESS_GRANTED则同意用户进行访问； </p>
<p>（2）如果全部弃权也表示通过； </p>
<p>（3）如果没有一个人投赞成票，但是有人投反对票，则将抛出AccessDeniedException。 </p>
<p>Spring security默认使用的是AffiffiffirmativeBased。 </p>
<p><strong>ConsensusBased</strong>的逻辑是： </p>
<p>（1）如果赞成票多于反对票则表示通过。 </p>
<p>（2）反过来，如果反对票多于赞成票则将抛出AccessDeniedException。 </p>
<p>（3）如果赞成票与反对票相同且不等于0，并且属性allowIfEqualGrantedDeniedDecisions的值为true，则表 </p>
<p>示通过，否则将抛出异常AccessDeniedException。参数allowIfEqualGrantedDeniedDecisions的值默认为true。 </p>
<p>（4）如果所有的AccessDecisionVoter都弃权了，则将视参数allowIfAllAbstainDecisions的值而定，如果该值 </p>
<p>为true则表示通过，否则将抛出异常AccessDeniedException。参数allowIfAllAbstainDecisions的值默认为false。 </p>
<p><strong>UnanimousBased</strong>的逻辑与另外两种实现有点不一样，另外两种会一次性把受保护对象的配置属性全部传递 </p>
<p>给AccessDecisionVoter进行投票，而UnanimousBased会一次只传递一个ConfifigAttribute给 AccessDecisionVoter进行投票。这也就意味着如果我们的AccessDecisionVoter的逻辑是只要传递进来的 ConfifigAttribute中有一个能够匹配则投赞成票，但是放到UnanimousBased中其投票结果就不一定是赞成了。 </p>
<p>UnanimousBased的逻辑具体来说是这样的： </p>
<p>（1）如果受保护对象配置的某一个ConfifigAttribute被任意的AccessDecisionVoter反对了，则将抛出 </p>
<p>AccessDeniedException。 </p>
<p>（2）如果没有反对票，但是有赞成票，则表示通过。 </p>
<p>（3）如果全部弃权了，则将视参数allowIfAllAbstainDecisions的值而定，true则通过，false则抛出 </p>
<p>AccessDeniedException。 </p>
<p>Spring Security也内置一些投票者实现类如<strong>RoleVoter</strong>、<strong>AuthenticatedVoter</strong>和<strong>WebExpressionVoter</strong>等，</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p><strong>获取用户信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getUserName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String userName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    SecurityContext context = SecurityContextHolder.getContext();</span><br><span class="line">    Authentication authentication = context.getAuthentication();</span><br><span class="line"></span><br><span class="line">    Object principal = authentication.getPrincipal();</span><br><span class="line">    <span class="keyword">if</span> (principal == <span class="keyword">null</span>)&#123;</span><br><span class="line">        userName = <span class="string">&quot;匿名&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (principal <span class="keyword">instanceof</span> UserDetails)&#123;</span><br><span class="line">        principal = (UserDetails) principal;</span><br><span class="line">        userName = ((UserDetails) principal).getUsername();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        userName = (String) principal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过以下选项准确控制会话何时创建以及Spring Security如何与之交互： </p>
<p><img src="/2021/03/04/framework/SpringSecurity/image-20210327151131193.png" alt="image-20210327151131193"></p>
<h3 id="基于方法的授权"><a href="#基于方法的授权" class="headerlink" title="基于方法的授权"></a>基于方法的授权</h3><p><strong>从数据库中获取权限信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Perm&gt; permList = permMapper.getPermDetails(s);</span><br><span class="line">String[] perms = <span class="keyword">new</span> String[permList.size()];</span><br><span class="line">permList.stream().map(Perm::getPerm).collect(Collectors.toList()).toArray(perms);</span><br><span class="line"></span><br><span class="line">UserDetails details = org.springframework.security.core.userdetails.User.builder()</span><br><span class="line">        .username(user.getUsername())</span><br><span class="line">        .password(user.getPassword())</span><br><span class="line">        .authorities(perms).build();</span><br><span class="line"><span class="keyword">return</span> details;</span><br></pre></td></tr></table></figure>

<p><strong>添加注解支持</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p><strong>使用注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/r/r1&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;p1&#x27;)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;r1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分布式认证系统方案"><a href="#分布式认证系统方案" class="headerlink" title="分布式认证系统方案"></a>分布式认证系统方案</h1><h2 id="认证方案"><a href="#认证方案" class="headerlink" title="认证方案"></a>认证方案</h2><h3 id="基于Session的认证"><a href="#基于Session的认证" class="headerlink" title="基于Session的认证"></a>基于Session的认证</h3><p><img src="/2021/03/04/framework/SpringSecurity/image-20210327164316978.png" alt="image-20210327164316978"></p>
<p>在分布式的环境下，基于session的认证会出现一个问题，每个应用服务都需要在session中存储用户身份信息，通 过负载均衡将本地的请求分配到另一个应用服务需要将session信息带过去，否则会重新认证。 </p>
<p>这个时候，通常的做法有下面几种： </p>
<p><strong>Session**</strong>复制**：多台应用服务器之间同步session，使session保持一致，对外透明。 </p>
<p><strong>Session**</strong>黏贴**：当用户访问集群中某台服务器后，强制指定后续所有请求均落到此机器上。 </p>
<p><strong>Session**</strong>集中存储**：将Session存入分布式缓存中，所有服务器应用实例统一</p>
<p>从分布式缓存中存取Session。 </p>
<p>总体来讲，基于session认证的认证方式，可以更好的在服务端对会话进行控制，且安全性较高。但是，session机 制方式基于cookie，在复杂多样的移动客户端上不能有效的使用，并且无法跨域，另外随着系统的扩展需提高 session的复制、黏贴及存储的容错性。</p>
<h3 id="基于Token的认证"><a href="#基于Token的认证" class="headerlink" title="##基于Token的认证"></a>##基于Token的认证</h3><p>基于token的认证方式，服务端不用存储认证数据，易维护扩展性强， 客户端可以把token 存在任意地方，并且可 以实现web和app统一认证机制。其缺点也很明显，token由于自包含信息，因此一般数据量较大，而且每次请求 都需要传递，因此比较占带宽。另外，token的签名验签操作也会给cpu带来额外的处理负担。</p>
<p><img src="/2021/03/04/framework/SpringSecurity/image-20210327164546595.png" alt="image-20210327164546595"></p>
<p><strong>根据 选型的分析，决定采用基于token的认证方式，它的优点是：</strong> </p>
<p>1、适合统一认证的机制，客户端、一方应用、三方应用都遵循一致的认证机制。 </p>
<p>2、token认证方式对第三方应用接入更适合，因为它更开放，可使用当前有流行的开放协议Oauth2.0、JWT等。 </p>
<p>3、一般情况服务端无需存储会话信息，减轻了服务端的压力。分布式系统认证技术方案见下图：</p>
<p><img src="/2021/03/04/framework/SpringSecurity/image-20210327164630515.png" alt="image-20210327164630515"></p>
<p><strong>流程描述：</strong> </p>
<p>（1）用户通过接入方（应用）登录，接入方采取OAuth2.0方式在统一认证服务(UAA)中认证。 </p>
<p>（2）认证服务(UAA)调用验证该用户的身份是否合法，并获取用户权限信息。 </p>
<p>（3）认证服务(UAA)获取接入方权限信息，并验证接入方是否合法。 </p>
<p>（4）若登录用户以及接入方都合法，认证服务生成jwt令牌返回给接入方，其中jwt中包含了用户权限及接入方权 </p>
<p>限。</p>
<p>（5）后续，接入方携带jwt令牌对API网关内的微服务资源进行访问。 </p>
<p>（6）API网关对令牌解析、并验证接入方的权限是否能够访问本次请求的微服务。 </p>
<p>（7）如果接入方的权限没问题，API网关将原请求header中附加解析后的明文Token，并将请求转发至微服务。 </p>
<p>（8）微服务收到请求，明文token中包含登录用户的身份和权限信息。因此后续微服务自己可以干两件事：1，用 </p>
<p>户授权拦截（看当前用户是否有权访问该资源）2，将用户信息存储进当前线程上下文（有利于后续业务逻辑随时 </p>
<p>获取当前用户信息）</p>
<p>流程所涉及到UAA服务、API网关这三个组件职责如下： </p>
<p><strong>1）统一证服务(UAA)</strong> </p>
<p>它承载了OAuth2.0接入方认证、登入用户的认证、授权以及生成令牌的职责，完成实际的用户认证、授权功能。 </p>
<p><strong>2）API网关</strong></p>
<p>作为系统的唯一入口，API网关为接入方提供定制的API集合，它可能还具有其它职责，如身份验证、监控、负载均 </p>
<p>衡、缓存等。API网关方式的核心要点是，所有的接入方和消费端都通过统一的网关接入微服务，<strong>在网关层处理所有的非业务功能。</strong></p>
<h2 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><img src="/2021/03/04/framework/SpringSecurity/image-20210327175423314.png" alt="image-20210327175423314"></p>
<p>OAuth2.0包括以下角色：</p>
<p>1、客户端 </p>
<p>本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏 览器端）、微信客户端等。 </p>
<p>2、资源拥有者 </p>
<p>通常为用户，也可以是应用程序，即该资源的拥有者。 </p>
<p>3、授权服务器（也称认证服务器）</p>
<p>用于服务提供商对资源拥有的身份进行认证、对访问资源进行授权，认证成功后会给客户端发放令牌 （access_token），作为客户端访问资源服务器的凭据。本例为微信的认证服务器。 </p>
<p>4、资源服务器 </p>
<p>存储资源的服务器，本例子为微信存储的用户信息。 现在还有一个问题，服务提供商能允许随便一个<strong>客户端</strong>就接入到它的<strong>授权服务器</strong>吗？</p>
<p>答案是否定的，服务提供商会 给准入的接入方一个身份，用于接入时的凭据: </p>
<p><strong>client_id</strong>：客户端标识 </p>
<p><strong>client_secret</strong>：客户端秘钥 </p>
<p>因此，准确来说，<strong>授权服务器</strong>对两种OAuth2.0中的两个角色进行认证授权，分别是<strong>资源拥有者</strong>、<strong>客户端</strong>。 </p>
<h4 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h4><p>OAuth2.0的服务提供方涵盖两个服务，即授权服务 (Authorization Server，也叫认证服务) 和资源服务 (Resource </p>
<p>Server)，使用 Spring Security OAuth2 的时候你可以选择把它们在同一个应用程序中实现，也可以选择建立使用 同一</p>
<p>个授权服务的多个资源服务。 </p>
<p><strong>授权服务</strong> <strong>(Authorization Server**</strong>）**应包含对接入端以及登入用户的合法性进行验证并颁发token等功能，对令牌 </p>
<p>的请求端点由 Spring MVC 控制器进行实现，下面是配置一个认证服务必须要实现的endpoints： </p>
<ul>
<li>AuthorizationENdpoint服务用于认证请求。默认url：<code>/oauth/authorize</code></li>
<li>TokenEndpoint服务用于访问令牌请求。默认url：<code>/oauth/token</code></li>
</ul>
<p>**资源服务(Rsource Server)**，应包含对资源的保护功能，对非法请求进行拦截，对请求中token进行解析鉴权等</p>
<ul>
<li>OAuth2AuthenticationProcessingFilter用来对请求给出的身份令牌解析鉴权。</li>
</ul>
<p><img src="/2021/03/04/framework/SpringSecurity/image-20210327180748655.png" alt="image-20210327180748655"></p>
<p>认证流程：</p>
<p>1、客户端请求UAA授权服务进行认证。 </p>
<p>2、认证通过后由UAA颁发令牌。 </p>
<p>3、客户端携带令牌Token请求资源服务。</p>
<p>4、资源服务校验令牌的合法性，合法即返回资源信息。 </p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.4.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-starter-oauth2 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.security.oauth.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-security-jwt&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>application.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">uaa‐service</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">53020</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/uaa</span></span><br><span class="line"><span class="meta">spring.main.allow‐bean‐definition‐overriding</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#datasource</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/spring_security?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">lz0210</span></span><br></pre></td></tr></table></figure>

<h4 id="授权服务器配置"><a href="#授权服务器配置" class="headerlink" title="授权服务器配置"></a>授权服务器配置</h4><p>可以用 @EnableAuthorizationServer 注解并继承AuthorizationServerConfifigurerAdapter来配置OAuth2.0 授权 服务器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title">AuthorizationServerConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorizationServerConfigurerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ClientDetailsServiceConfifigurer</strong>：用来配置客户端详情服（ClientDetailsService），客户端详情信息在 这里进行初始化，你能够把客户端详情信息写死在这里或者是通过数据库来存储调取详情信息。 </p>
<p><strong>AuthorizationServerEndpointsConfifigurer</strong>：用来配置令牌（token）的访问端点和令牌服务(token services)。 </p>
<p><strong>AuthorizationServerSecurityConfifigurer</strong>：用来配置令牌端点的安全约束。</p>
<h5 id="配置客户端详细信息"><a href="#配置客户端详细信息" class="headerlink" title="配置客户端详细信息"></a>配置客户端详细信息</h5><p>ClientDetailsServiceConfifigurer 能够使用内存或者JDBC来实现客户端详情服务（ClientDetailsService）， ClientDetailsService负责查找ClientDetails，而ClientDetails有几个重要的属性如下列表： </p>
<ul>
<li><p>clientId：（必须的）用来标识客户的Id。 </p>
</li>
<li><p>secret：（需要值得信任的客户端）客户端安全码，如果有的话。 </p>
</li>
<li><p>scope：用来限制客户端的访问范围，如果为空（默认）的话，那么客户端拥有全部的访问范围。 </p>
</li>
<li><p>authorizedGrantTypes：此客户端可以使用的授权类型，默认为空。 </p>
</li>
<li><p>authorities：此客户端可以使用的权限（基于Spring Security authorities）。 </p>
</li>
</ul>
<p>客户端详情（Client Details）能够在应用程序运行的时候进行更新，可以通过访问底层的存储服务（例如将客户 端详情存储在一个关系数据库的表中，就可以使用 JdbcClientDetailsService）或者通过自己实现 ClientRegistrationService接口（同时你也可以实现 ClientDetailsService 接口）来进行管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        clients.withClientDetails(clientDetailsService);</span></span><br><span class="line"></span><br><span class="line">        clients.inMemory()  <span class="comment">//使用in-memory存储</span></span><br><span class="line">                .withClient(<span class="string">&quot;c1&quot;</span>)</span><br><span class="line">                .secret(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;secret&quot;</span>))</span><br><span class="line">                .resourceIds(<span class="string">&quot;res1&quot;</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;client_credentials&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;implicit&quot;</span>, <span class="string">&quot;refresh_token&quot;</span>)</span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                .autoApprove(<span class="keyword">false</span>)</span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="管理令牌"><a href="#管理令牌" class="headerlink" title="管理令牌"></a>管理令牌</h5><p>AuthorizationServerTokenServices 接口定义了一些操作使得你可以对令牌进行一些必要的管理，令牌可以被用来 加载身份信息，里面包含了这个令牌的相关权限。</p>
<p>自己可以创建 AuthorizationServerTokenServices 这个接口的实现，则需要继承 <strong>DefaultTokenServices</strong> 这个类， 里面包含了一些有用实现，你可以使用它来修改令牌的格式和令牌的存储。默认的，当它尝试创建一个令牌的时 候，是使用随机值来进行填充的，除了持久化令牌是委托一个 TokenStore 接口来实现以外，这个类几乎帮你做了 所有的事情。并且 TokenStore 这个接口有一个默认的实现，它就是 InMemoryTokenStore/</p>
<ul>
<li>InMemoryTokenStore：这个版本的实现是被默认采用的，它可以完美的工作在单服务器上（即访问并发量 </li>
</ul>
<p>压力不大的情况下，并且它在失败的时候不会进行备份），大多数的项目都可以使用这个版本的实现来进行 </p>
<p>尝试，你可以在开发的时候使用它来进行管理，因为不会被保存到磁盘中，所以更易于调试。 </p>
<ul>
<li><p>JdbcTokenStore：这是一个基于JDBC的实现版本，令牌会被保存进关系型数据库。使用这个版本的实现时， 你可以在不同的服务器之间共享令牌信息。</p>
</li>
<li><p>JwtTokenStore：这个版本的全称是 JSON Web Token（JWT），它可以把令牌相关的数据进行编码（因此对 于后端服务来说，它不需要进行存储，这将是一个重大优势），但是它有一个缺点，那就是撤销一个已经授 权令牌将会非常困难，所以它通常用来处理一个生命周期较短的令牌以及撤销刷新令牌（refresh_token）。 另外一个缺点就是这个令牌占用的空间会比较大，如果你加入了比较多用户凭证信息。JwtTokenStore 不会保 牌值以及授权信息方面与 DefaultTokenServices 所扮演的角色是一样的。 </p>
</li>
</ul>
<p><strong>定义Tokenconfig</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class TokenConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public TokenStore tokenStore() &#123;</span><br><span class="line">        return new InMemoryTokenStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义AuthorizationServerTokenServices在AuthorizationServer中定义AuthorizationServerTokenServices</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthorizationServerTokenServices <span class="title">tokenService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultTokenServices service = <span class="keyword">new</span> DefaultTokenServices();</span><br><span class="line">    service.setClientDetailsService(clientDetailsService);</span><br><span class="line">    service.setSupportRefreshToken(<span class="keyword">true</span>);</span><br><span class="line">    service.setTokenStore(tokenStore);</span><br><span class="line">    service.setAccessTokenValiditySeconds(<span class="number">7200</span>); <span class="comment">// 令牌默认有效期2小时</span></span><br><span class="line">    service.setRefreshTokenValiditySeconds(<span class="number">259200</span>); <span class="comment">// 刷新令牌默认有效期3天</span></span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="令牌访问端点配置"><a href="#令牌访问端点配置" class="headerlink" title="令牌访问端点配置"></a>令牌访问端点配置</h5><p>AuthorizationServerEndpointsConfifigurer 这个对象的实例可以完成令牌服务以及令牌endpoint配置。</p>
<p><strong>配置授权类型（Grant Types）</strong></p>
<ul>
<li><p>authenticationManager：认证管理器，当你选择了资源所有者密码（password）授权类型的时候，请设置 这个属性注入一个 AuthenticationManager 对象。 </p>
</li>
<li><p>userDetailsService：如果你设置了这个属性的话，那说明你有一个自己的 UserDetailsService 接口的实现， 或者你可以把这个东西设置到全局域上面去（例如 GlobalAuthenticationManagerConfifigurer 这个配置对 象），当你设置了这个之后，那么 “refresh_token” 即刷新令牌授权类型模式的流程中就会包含一个检查，用 来确保这个账号是否仍然有效，假如说你禁用了这个账户的话。</p>
</li>
<li><p>authorizationCodeServices：这个属性是用来设置授权码服务的（即 AuthorizationCodeServices 的实例对象），主要用于 “authorization_code” 授权码类型模式。 </p>
</li>
<li><p>implicitGrantService：这个属性用于设置隐式授权模式，用来管理隐式授权模式的状态。 </p>
</li>
<li><p>tokenGranter：当你设置了这个东西（即 TokenGranter 接口实现），那么授权将会交由你来完全掌控，并 且会忽略掉上面的这几个属性，这个属性一般是用作拓展用途的，即标准的四种授权模式已经满足不了你的 需求的时候，才会考虑使用这个。</p>
</li>
</ul>
<p><strong>配置授权端点的URL</strong></p>
<p>AuthorizationServerEndpointsConfifigurer 这个配置对象有一个叫做 pathMapping() 的方法用来配置端点URL链 接，它有两个参数：</p>
<ul>
<li><p>第一个参数：String 类型的，这个端点URL的默认链接。 </p>
</li>
<li><p>第二个参数：String 类型的，你要进行替代的URL链接。</p>
</li>
</ul>
<p>以上的参数都将以 “/“ 字符为开始的字符串，框架的默认URL链接如下列表，可以作为这个 pathMapping() 方法的 第一个参数：</p>
<ul>
<li><p>/oauth/authorize：授权端点。 </p>
</li>
<li><p>/oauth/token：令牌端点。 </p>
</li>
<li><p>/oauth/confirm_access：用户确认授权提交端点。 </p>
</li>
<li><p>/oauth/error：授权服务错误信息端点。 </p>
</li>
<li><p>/oauth/check_token：用于资源服务访问的令牌解析端点。 </p>
</li>
<li><p>/oauth/token_key：提供公有密匙的端点，如果你使用JWT令牌的话。</p>
</li>
</ul>
<p>需要注意的是授权端点这个URL应该被Spring Security保护起来只供授权用户访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    endpoints.authenticationManager(authenticationManager)</span><br><span class="line">            .authorizationCodeServices(authorizationCodeServices())</span><br><span class="line">            .tokenServices(tokenService())</span><br><span class="line">            .allowedTokenEndpointRequestMethods(HttpMethod.POST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthorizationCodeServices <span class="title">authorizationCodeServices</span><span class="params">()</span> </span>&#123;  <span class="comment">//设置授权码模式的授权码如何存储，这里采用内存的模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InMemoryAuthorizationCodeServices();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ps</strong></p>
<p>加入AuthencationManager依赖时在WebSecurityConfig里面加入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="令牌端点的安全约束"><a href="#令牌端点的安全约束" class="headerlink" title="令牌端点的安全约束"></a>令牌端点的安全约束</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    security</span><br><span class="line">            .tokenKeyAccess(<span class="string">&quot;permitAll()&quot;</span>)  <span class="comment">//oauth/token_kejavay公开</span></span><br><span class="line">            .checkTokenAccess(<span class="string">&quot;permitAll()&quot;</span>)    <span class="comment">///oauth/check_token公开</span></span><br><span class="line">            .allowFormAuthenticationForClients();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）tokenkey这个endpoint当使用JwtToken且使用非对称加密时，资源服务用于获取公钥而开放的，这里指这个 endpoint完全公开。 </p>
<p>（2）checkToken这个endpoint完全公开 </p>
<p>（3） 允许表单认证 </p>
<h5 id="web安全配置"><a href="#web安全配置" class="headerlink" title="web安全配置"></a>web安全配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="string">&quot;zhangsan&quot;</span>).password(<span class="string">&quot;$2a$10$KhAWzl.osgD3AH/TVU9G4OZcbzHkRC6RVJmT/6DheKeazWYhX6xE.&quot;</span>).authorities(<span class="string">&quot;p1&quot;</span>).build());</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)</span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/r/r1&quot;</span>).hasAuthority(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/r/r2&quot;</span>).hasAuthority(<span class="string">&quot;p2&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/login*&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .formLogin().successForwardUrl(<span class="string">&quot;/login-success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><h5 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h5><p><img src="/2021/03/04/framework/SpringSecurity/image-20210328133614203.png" alt="image-20210328133614203"></p>
<p>（<strong>1</strong>）<strong>资源拥有者打开客户端，客户端要求资源拥有者给予授权，它将浏览器被重定向到授权服务器，重定向时附加客户端的身份信息，如：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;uaa&#x2F;oauth&#x2F;authorize?client_id&#x3D;c1&amp;response_type&#x3D;code&amp;scope&#x3D;all&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure>

<p>参数列表：</p>
<ul>
<li>client_id：客户端准入标识</li>
<li>response_type：授权码模式固定为code</li>
<li>scope：客户端权限</li>
<li>redirect_url：跳转uri，当授权码申请成功后会跳转到此地址，并在后边code参数(授权码)。</li>
</ul>
<p><strong>（2）浏览器出现向授权服务器授权界面，之后用户同意授权</strong></p>
<p>**（3）授权服务器将授权码（AuthorizationCode）转经浏览器发送给client（通过redirect_uri)**。</p>
<p><strong>（4）客户端拿着授权码向授权服务器索要访问access_token，请求如下：</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;uaa&#x2F;oauth&#x2F;token? client_id&#x3D;c1&amp;client_secret&#x3D;secret&amp;grant_type&#x3D;authorization_code&amp;code&#x3D;5PgfcD&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure>

<p>参数列表如下 :</p>
<ul>
<li><p>client_id：客户端准入标识。 </p>
</li>
<li><p>client_secret：客户端秘钥。 </p>
</li>
<li><p>grant_type：授权类型，填写authorization_code，表示授权码模式 </p>
</li>
<li><p>code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。 </p>
</li>
<li><p>redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。</p>
</li>
</ul>
<p><strong>（5）授权服务器返回令牌(access_token)</strong> </p>
<p>这种模式是四种模式中最安全的一种模式。一般用于<strong>client是Web服务器端应用或第三方的原生App调用资源服务 的时候。</strong>因为在这种模式中access_token不会经过浏览器或移动端的App，而是直接从服务端去交换，这样就最 限度的减小了令牌泄漏的风险。</p>
<h5 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h5><p><img src="/2021/03/04/framework/SpringSecurity/image-20210328135248167.png" alt="image-20210328135248167"></p>
<p><strong>资源拥有者打开客户端，客户端要求资源拥有者给予授权，它将浏览器被重定向到授权服务器，重定向时会附加客户端的身份信息。如：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;uaa&#x2F;oauth&#x2F;authorize?client_id&#x3D;c1&amp;response_type&#x3D;token&amp;scope&#x3D;all&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure>

<p>参数描述同<strong>授权码模式</strong> ，注意response_type=token，说明是简化模式。</p>
<p><strong>（2）浏览器出现向授权服务器授权页面，之后将用户同意授权。</strong> </p>
<p>（<strong>3）授权服务器将授权码将令牌（access_token）以Hash的形式存放在重定向uri的fargment中发送给浏览器。</strong></p>
<p>==般来说，简化模式用于没有服务器端的第三方单页面应用，因为没有服务器端就无法接收授权码。==</p>
<h5 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h5><p><img src="/2021/03/04/framework/SpringSecurity/image-20210328135634399.png" alt="image-20210328135634399"></p>
<p><strong>（1）资源拥有者将用户名、密码发送给客户端</strong> </p>
<p><strong>（2）客户端拿着资源拥有者的用户名、密码向授权服务器请求令牌（access_token），请求如下：</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;uaa&#x2F;oauth&#x2F;token? client_id&#x3D;c1&amp;client_secret&#x3D;secret&amp;grant_type&#x3D;password&amp;username&#x3D;shangsan&amp;password&#x3D;123</span><br></pre></td></tr></table></figure>

<p>参数列表如下： </p>
<ul>
<li><p>client_id：客户端准入标识。 </p>
</li>
<li><p>client_secret：客户端秘钥。 </p>
</li>
<li><p>grant_type：授权类型，填写password表示密码模式 </p>
</li>
<li><p>username：资源拥有者用户名。 </p>
</li>
<li><p>password：资源拥有者密码。</p>
</li>
</ul>
<p><strong>（3）授权服务器将令牌（access_token）发送给client</strong> </p>
<p>这种模式十分简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我 们自己开发的情况下。因此密码模式一般用于我们自己开发的，第一方原生App或第一方单页面应用</p>
<h5 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h5><p><img src="/2021/03/04/framework/SpringSecurity/image-20210328135915042.png" alt="image-20210328135915042"></p>
<p><strong>（1）客户端向授权服务器发送自己的身份信息，并请求令牌（access_token）</strong> </p>
<p><strong>（2）确认客户端身份无误后，将令牌（access_token）发送给client，请求如下：**</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;uaa&#x2F;oauth&#x2F;token?client_id&#x3D;c1&amp;client_secret&#x3D;secret&amp;grant_type&#x3D;client_credentials</span><br></pre></td></tr></table></figure>

<p>参数列表如下： </p>
<ul>
<li><p>client_id：客户端准入标识。 </p>
</li>
<li><p>client_secret：客户端秘钥。 </p>
</li>
<li><p>grant_type：授权类型，填写client_credentials表示客户端模式 </p>
</li>
</ul>
<p>==这种模式是最方便但最不安全的模式。因此这就要求我们对client完全的信任，而client本身也是安全的。因 此这种模式一般用来提供给我们完全信任的服务器端服务。比如，合作方系统对接，拉取一组用户信息。==</p>
<h4 id="资源服务器配置"><a href="#资源服务器配置" class="headerlink" title="资源服务器配置"></a>资源服务器配置</h4><h5 id="资源服务器配置-1"><a href="#资源服务器配置-1" class="headerlink" title="资源服务器配置"></a>资源服务器配置</h5><p>@EnableResourceServer 注解到一个 @Confifiguration 配置类上，并且必须使用 ResourceServerConfifigurer 个 配置对象来进行配置（可以选择继承自 ResourceServerConfifigurerAdapter 然后覆写其中的方法，参数就是这个 对象的实例），下面是一些可以配置的属性： </p>
<p>ResourceServerSecurityConfifigurer中主要包括： </p>
<ul>
<li><p>tokenServices：ResourceServerTokenServices 类的实例，用来实现令牌服务。 </p>
</li>
<li><p>tokenStore：TokenStore类的实例，指定令牌如何访问，与tokenServices配置可选 </p>
</li>
<li><p>resourceId：这个资源服务的ID，这个属性是可选的，但是推荐设置并在授权服务中进行验证。 </p>
</li>
<li><p>其他的拓展属性例如 tokenExtractor 令牌提取器用来提取请求中的令牌。 </p>
</li>
</ul>
<p>HttpSecurity配置这个与Spring Security类似：</p>
<ul>
<li><p>请求匹配器，用来设置需要进行保护的资源路径，默认的情况下是保护资源服务的全部路径。 </p>
</li>
<li><p>通过http.authorizeRequests()来设置受保护资源的访问规则 </p>
</li>
<li><p>其他的自定义权限保护规则通过 HttpSecurity 来进行配置。</p>
</li>
</ul>
<p>@EnableResourceServer 注解自动增加了一个类型为OAuth2AuthenticationProcessingFilter 的过滤器链 编写ResouceServerConfifig：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServiceConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_ID = <span class="string">&quot;res1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        resources.resourceId(RESOURCE_ID)</span><br><span class="line">                .tokenServices(tokenService())</span><br><span class="line">                .stateless(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceServerTokenServices <span class="title">tokenService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用远程服务请求授权服务器校验token,必须指定校验token 的url、client_id，client_secret</span></span><br><span class="line">        RemoteTokenServices tokenServices = <span class="keyword">new</span> RemoteTokenServices();</span><br><span class="line">        tokenServices.setCheckTokenEndpointUrl(<span class="string">&quot;http://localhost:53020/uaa/oauth/check_token&quot;</span>);</span><br><span class="line">        tokenServices.setClientId(<span class="string">&quot;c1&quot;</span>);</span><br><span class="line">        tokenServices.setClientSecret(<span class="string">&quot;secret&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tokenServices;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/**&quot;</span>).access(<span class="string">&quot;#oauth2.hasScope(&#x27;all&#x27;)&quot;</span>)</span><br><span class="line">                .and().csrf().disable()</span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.2.7.2</strong> <strong>验证**</strong>token** </p>
<p>ResourceServerTokenServices 是组成授权服务的另一半，如果你的授权服务和资源服务在同一个应用程序上的 话，你可以使用 DefaultTokenServices ，这样的话，你就不用考虑关于实现所有必要的接口的一致性问题。如果 你的资源服务器是分离开的，那么你就必须要确保能够有匹配授权服务提供的ResourceServerTokenServices，它 知道如何对令牌进行解码。</p>
<p><strong>令牌解析方法</strong>： </p>
<p>​    使用 DefaultTokenServices 在资源服务器本地配置令牌存储、解码、解析方式 </p>
<p>​    使用 RemoteTokenServices 资源服务器通过 HTTP 请求来解码令牌，每次都请求授权服务器端点 /oauth/check_token 使用授权服务的 /oauth/check_token 端点你需要在授权服务将这个端点暴露出去，以便资源服务可以进行访问， </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    security</span><br><span class="line">            .tokenKeyAccess(<span class="string">&quot;permitAll()&quot;</span>)  <span class="comment">//oauth/token_key公开</span></span><br><span class="line">            .checkTokenAccess(<span class="string">&quot;permitAll()&quot;</span>)    <span class="comment">///oauth/check_token公开</span></span><br><span class="line">            .allowFormAuthenticationForClients();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==在资源 服务配置RemoteTokenServices ，在ResouceServerConfifig中配置：==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResourceServerTokenServices <span class="title">tokenService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用远程服务请求授权服务器校验token,必须指定校验token 的url、client_id，client_secret</span></span><br><span class="line">    RemoteTokenServices tokenServices = <span class="keyword">new</span> RemoteTokenServices();</span><br><span class="line">    tokenServices.setCheckTokenEndpointUrl(<span class="string">&quot;http://localhost:53020/uaa/oauth/check_token&quot;</span>);</span><br><span class="line">    tokenServices.setClientId(<span class="string">&quot;c1&quot;</span>);</span><br><span class="line">    tokenServices.setClientSecret(<span class="string">&quot;secret&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> tokenServices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>test</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/r1&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAnyAuthority(&#x27;p2&#x27;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">r1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;访问资源1&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>添加安全访问控制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)</span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">/*.antMatchers(&quot;/r/r1&quot;).hasAuthority(&quot;p1&quot;)</span></span><br><span class="line"><span class="comment">                .antMatchers(&quot;/r/r2&quot;).hasAuthority(&quot;p2&quot;)*/</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/login*&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .formLogin().successForwardUrl(<span class="string">&quot;/login-success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请求资源</strong> </p>
<p>按照oauth2.0协议要求，请求资源需要携带token，如下： </p>
<p>token的参数名称为：<strong>Authorization</strong>，值为：<strong>Bearer token</strong>值</p>
<h4 id="使用JWT令牌"><a href="#使用JWT令牌" class="headerlink" title="使用JWT令牌"></a>使用JWT令牌</h4><p><strong>jWT令牌的组成</strong></p>
<p>xxx.xxx.xxx</p>
<p><strong>第一部分</strong>：header 包含令牌的类型及使用的算法</p>
<p><strong>第二部分</strong>：payload 存放一些用户信息</p>
<p><strong>第三部分</strong>：signature HMACSHA256( base64UrlEncode(header) + “.”+base64UrlEncode(payload), secret) </p>
<p><strong>1.TokenConfig</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SIGNING_KEY = <span class="string">&quot;uaa123&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenStore <span class="title">tokenStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenStore(accessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">accessTokenConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">        converter.setSigningKey(SIGNING_KEY); <span class="comment">//对称秘钥，资源服务器使用该秘钥来验证 return converter;</span></span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  @Bean</span></span><br><span class="line"><span class="comment">    public TokenStore tokenStore() &#123;</span></span><br><span class="line"><span class="comment">        return new InMemoryTokenStore();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.定义JWT令牌服务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter accessTokenConverter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationServerTokenServices <span class="title">tokenService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultTokenServices service = <span class="keyword">new</span> DefaultTokenServices();</span><br><span class="line">        service.setClientDetailsService(clientDetailsService);</span><br><span class="line">        service.setSupportRefreshToken(<span class="keyword">true</span>);</span><br><span class="line">        service.setTokenStore(tokenStore);</span><br><span class="line">        <span class="comment">//使用jwt令牌的形式</span></span><br><span class="line">        TokenEnhancerChain tokenEnhancerChain = <span class="keyword">new</span> TokenEnhancerChain();</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter));</span><br><span class="line">        service.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line"></span><br><span class="line">        service.setAccessTokenValiditySeconds(<span class="number">7200</span>); <span class="comment">// 令牌默认有效期2小时</span></span><br><span class="line">        service.setRefreshTokenValiditySeconds(<span class="number">259200</span>); <span class="comment">// 刷新令牌默认有效期3天</span></span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.校验JWT令牌</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServiceConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_ID = <span class="string">&quot;res1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        resources.resourceId(RESOURCE_ID)</span><br><span class="line">                .tokenStore(tokenStore)</span><br><span class="line"><span class="comment">//                .tokenServices(tokenService())</span></span><br><span class="line">                .stateless(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@Bean</span></span><br><span class="line"><span class="comment">    public ResourceServerTokenServices tokenService() &#123;</span></span><br><span class="line"><span class="comment">        //使用远程服务请求授权服务器校验token,必须指定校验token 的url、client_id，client_secret</span></span><br><span class="line"><span class="comment">        RemoteTokenServices tokenServices = new RemoteTokenServices();</span></span><br><span class="line"><span class="comment">        tokenServices.setCheckTokenEndpointUrl(&quot;http://localhost:53020/uaa/oauth/check_token&quot;);</span></span><br><span class="line"><span class="comment">        tokenServices.setClientId(&quot;c1&quot;);</span></span><br><span class="line"><span class="comment">        tokenServices.setClientSecret(&quot;secret&quot;);</span></span><br><span class="line"><span class="comment">        return tokenServices;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完善环境配置"><a href="#完善环境配置" class="headerlink" title="完善环境配置"></a>完善环境配置</h4><p><strong>使用数据库存储客户端信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">ClientDetailsService <span class="title">clientDetailsService</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">    JdbcClientDetailsService detailsService = <span class="keyword">new</span> JdbcClientDetailsService(dataSource);</span><br><span class="line">    detailsService.setPasswordEncoder(passwordEncoder);</span><br><span class="line">    <span class="keyword">return</span> detailsService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    clients.withClientDetails(clientDetailsService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationCodeServices <span class="title">authorizationCodeServices</span><span class="params">(DataSource dataSource)</span> </span>&#123;  <span class="comment">//设置授权码模式的授权码如何存储，这里采用内存的模式</span></span><br><span class="line"><span class="comment">//        return new InMemoryAuthorizationCodeServices();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAuthorizationCodeServices(dataSource);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用数据库存储授权码信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationCodeServices <span class="title">authorizationCodeServices</span><span class="params">(DataSource dataSource)</span> </span>&#123;  <span class="comment">//设置授权码模式的授权码如何存储，这里采用内存的模式</span></span><br><span class="line"><span class="comment">//        return new InMemoryAuthorizationCodeServices();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAuthorizationCodeServices(dataSource);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring%E6%8A%80%E6%9C%AF%E6%A0%88/" rel="tag"># Spring技术栈</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/23/language/python/python/" rel="prev" title="python">
      <i class="fa fa-chevron-left"></i> python
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/14/framework/rabbitmq/" rel="next" title="rabbitmq">
      rabbitmq <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E6%80%BB%E8%A7%88"><span class="nav-number">1.1.</span> <span class="nav-text">结构总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">认证流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">认证流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AuthenticationProvider"><span class="nav-number">1.2.2.</span> <span class="nav-text">AuthenticationProvider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UserDetailService"><span class="nav-number">1.2.3.</span> <span class="nav-text">UserDetailService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PasswordEncoder"><span class="nav-number">1.2.4.</span> <span class="nav-text">PasswordEncoder</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">授权流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">授权流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%88%E6%9D%83%E7%AD%96%E7%95%A5"><span class="nav-number">1.3.2.</span> <span class="nav-text">授权策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-number">1.3.3.</span> <span class="nav-text">会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%96%B9%E6%B3%95%E7%9A%84%E6%8E%88%E6%9D%83"><span class="nav-number">1.3.4.</span> <span class="nav-text">基于方法的授权</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88"><span class="nav-number">2.</span> <span class="nav-text">分布式认证系统方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E6%96%B9%E6%A1%88"><span class="nav-number">2.1.</span> <span class="nav-text">认证方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ESession%E7%9A%84%E8%AE%A4%E8%AF%81"><span class="nav-number">2.1.1.</span> <span class="nav-text">基于Session的认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EToken%E7%9A%84%E8%AE%A4%E8%AF%81"><span class="nav-number">2.1.2.</span> <span class="nav-text">##基于Token的认证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OAuth2-0"><span class="nav-number">2.2.</span> <span class="nav-text">OAuth2.0</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.2.0.2.</span> <span class="nav-text">环境介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.1.</span> <span class="nav-text">环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">授权服务器配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="nav-number">2.2.1.2.1.</span> <span class="nav-text">配置客户端详细信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E4%BB%A4%E7%89%8C"><span class="nav-number">2.2.1.2.2.</span> <span class="nav-text">管理令牌</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A4%E7%89%8C%E8%AE%BF%E9%97%AE%E7%AB%AF%E7%82%B9%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.1.2.3.</span> <span class="nav-text">令牌访问端点配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A4%E7%89%8C%E7%AB%AF%E7%82%B9%E7%9A%84%E5%AE%89%E5%85%A8%E7%BA%A6%E6%9D%9F"><span class="nav-number">2.2.1.2.4.</span> <span class="nav-text">令牌端点的安全约束</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#web%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.1.2.5.</span> <span class="nav-text">web安全配置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.1.3.1.</span> <span class="nav-text">授权码模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.1.3.2.</span> <span class="nav-text">简化模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.1.3.3.</span> <span class="nav-text">密码模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.1.3.4.</span> <span class="nav-text">客户端模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">资源服务器配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE-1"><span class="nav-number">2.2.1.4.1.</span> <span class="nav-text">资源服务器配置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JWT%E4%BB%A4%E7%89%8C"><span class="nav-number">2.2.1.5.</span> <span class="nav-text">使用JWT令牌</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%96%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.1.6.</span> <span class="nav-text">完善环境配置</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LZ</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
